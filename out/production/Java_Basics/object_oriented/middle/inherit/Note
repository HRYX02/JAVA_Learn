面向对象的特征之二：继承性(inheritance)
    1 继承性的好处(why)：
        （1）减少代码冗余
        （2）便于功能的扩展
        （3）为多态性的使用提供了前提
    2 继承性的格式：class A extends B {}
        A:子类、派生类、subclass
        B:父类、超类、基类、superclass

        2.1 体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的结构-->(所有的属性、方法)
            特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私
            有的结构。只是因为封装性的影响，使得子 类不能直接调用父类的结构而已。
        2.2 子类继承父类以后，还可以声明自己特有的属性和方法，实现功能的拓展。
            子类和父类的关系 != 数学的集合
    3 Java中关于继承性的规定
        3.1 一个类可被多个子类继承，而一个子类只能有一个父类 -->类的单继承性
        3.2 子父类是相对的，可多次继承
        3.3 子类直接继承的父类叫直接父类；间接继承的父类称为间接父类
        3.4 子类继承父类后，就获取了直接父类以及所有间接父类中声明的属性和方法
    4
        (1) 如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类
        (2) 所有的java类（除java.lang.Object类）都直接或间接的继承java.lang.Object类
        (3) 意味着，所有的java类具有java.lang.Object类声明的功能
    5 方法的重写(override/overwrite)
        (1) 重写：子类继承父类以后，可以对父类中同名同参数的方法进行覆盖操作
        (2) 应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同
                 名同参数的方法时，实际执行的是子类重写父类的方法
        (3) 重写的规定：
                1 方法的声明：权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{
                          方法体
                          }
                2 约定俗成：子类中的叫重写的方法，父类中的叫被重写的方法
                ① 子类重写的方法的方法名和形参列表与父类被重写的方法名和形参列表相同
                ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
                   >特别的：子类中不能重写父类中声明为private权限的方法
                ③ 返回值类型“
                    (1) 父类被重写的方法发返回值是void，则子类重写的方法的返回值也只能是void
                    (2) 父类被重写的方法发返回值是A类型，则子类重写的方法的返回值可以是A类或A类的子类
                    (3) 父类被重写的方法发返回值是基本数据类型，则子类重写的方法的返回值必须是相同的基本数据类型
                    (4) 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型
        (4) 子类和父类的同名同参的方法要么都声明为static(不是重写)的，要么都声明为非static的。(主要考虑非static)
    6 super关键字
        1 (1)理解为：父类的
          (2)用来调用：属性、方法、构造器
        2 2.1 使用(属性、方法):
             (1) 我们可以在子类的方法或构造器中，通过使用"super.属性"或"super.方法"的方式，显示的调用父类中声明的属性或方法，
                 但是，通常情况下，我们习惯省略super
             (2) 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，
                 则必须显式的使用"super.属性"的方式表明调用的是父类中声明的属性
             (3) 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，
                 则必须显式的使用"super.方法"的方式表明调用的是父类中声明的方法
          2.2 使用(构造器)：
             (1) 我们可以在子类的构造器中显示的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
             (2) "super(形参列表)"的使用必须声明在子类构造器的首行
             (3) 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现
             (4)＊ 在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造[super()]
             (5) 在类的多个构造器中,至少有一个类的构造器中使用了"super(形参列表)",调用父类中的构造器
    7 子类对象实例化的全过程(理解):
        1 从结果上来看(继承性):
           子类继承父类以后,就获取了父类中声明的属性和方法。
           创建子类的对象,在堆空间中，就会加载所有父类中声明的属性
        2 从过程上来看:
            当我们通过子类的构造器创建子类对象时,我们一定会直接或间接的调用其父类的构造器,进而调用父类的父类的构造器...
            直到调用了java.lang.Object类中空参的构造器为止.正因为加载过所有的父类的结构,所有才可以看到内存中有父类的
            结构,子类对象才可以考虑进行调用
        3 明确:
            虽然创建子类对象时,调用了父类的构造器,但自始至终就创建过一个对象,即为new的子类对象